---
title: 密码技术与物联网安全之单向散列函数
date: 2019-07-06 14:44:47
tags: 物联网安全 mbedtls 单向散列函数 
---

## 前言
由于工作的原因，初次接触安全芯片并使用到安全相关的一些工具，并在后续的学习中陆陆续续看了一些安全的知识。~~为了避免过段时间不用又全部忘记掉，故~~在此做一些security相关的笔记，希望之后可以温故知新，也希望能帮助到有需要的同学。
我主要参考了以下三本书籍，感兴趣的同学可以看看：
- [《图解密码技术》][link1] ：非常浅显易懂的入门书籍
- [《密码技术与物联网安全 -- mbedtls开发实战》][link2]：19年出的mbedtls相关的书籍
- [《密码编码学与网络安全 -- 原理与实践》][link3]：有很多推导证明的教科书，~~比较枯燥，没怎么看。~~

另外参考了别人的博文和维基百科，在此表示感谢：

- [SHA256算法原理详解][link4]
- [SHA-2][link5]

[link1]:https://book.douban.com/subject/26265544/
[link2]:https://item.jd.com/12507477.html
[link3]:https://book.douban.com/subject/1142306/
[link4]:https://blog.csdn.net/u011583927/article/details/80905740
[link5]:https://en.wikipedia.org/wiki/SHA-2

<!--more-->

## 单向散列函数
### 什么是单向散列函数
单项散列函数又称安全散列函数或哈希函数（Hash function），是一种从任何数据中创建小的数字“指纹”(fingerprint)的方法，可用于检查消息的完整性。

Okay，用我自己的话来理解一遍：
```
- 它是一个函数，输入是你的消息（任意长度的），输出是小的数字“指纹”（长度固定的）；
- 既然是指纹，那么它对和消息必须是唯一对应（抗碰撞性）；
- 散列函数可以用来检查消息的完整性。
```
![hash](密码技术与物联网安全之单向散列函数/hash.png)

根据上面的描述，我们很容易联想到通信校验中常用到的crc。这时候我们会冒出一个问题：crc8/crc32能否作为单向散列函数，它和常用的散列函数如sha256有什么区别？

这个问题在我们了解了单项散列函数的性质之后再做回答。
单项散列函数为了满足安全的要求，需要满足以下性质：
```
输出长度可变，输出长度固定；
高效率：计算h(x)较为容易；
单向性：给定输出z，通过计算找到满足h(x) = z的输入是不可行的；
抗碰撞性：找到满足h(x1) = h(x2)的一对x1、x2（x1 ≠ x2）在计算上是不可行的；
伪随机性：满足伪随机性测试标准。
```
满足以上性质的散列函数，如SHA256，和CRC的区别有以下几点：
- 算法不同。crc用的是多项式除法，sha用的是替换、轮转等更复杂的运算；
- 安全性不同。crc的安全性较弱，sha的安全性则高很多；
- 效率不同。crc计算很快，sha效率相对慢很多；
- 用途不同。crc一般用做通信数据的校验；sha用于安全领域，比如文件校验、数字签名等。

### 单项散列函数的应用
#### 消息完整性检测
单向散列函数的一个重要应用是对消息的完整性进行检测。例如在传输消息的后面添加散列值，在传输完成之后再比较计算出来的散列值和收到的散列值是否相等，来检测是否发生了篡改。
#### 伪随机数生成器
单向散列函数可以用来构造伪随机数生成算法，如TLS1.2中的PRF函数。
#### 消息认证码
消息认证码用来检测消息传输过程中的错误、篡改和伪装。什么是伪装呢？比如Alice向Bob传输了一条带有散列值的消息，但是这个传输过程被Mallory截获，并且Mallory伪装成Alice发了一条新的消息+散列值给Bob。消息认证码就是为了完成认证的过程：它除了单项散列函数外还加入了共享密钥，该密钥只有Alice和Bob有，这样就能防止伪装，完成认证。
#### 数字签名
因为“指纹”代表了数据的真实性，因此一般对“指纹”进行签名而不是对完整消息进行签名（太慢）。
### SHA256详细描述
单向散列函数的实现方法有很多种，常用的包括MD4、MD5、SHA-256、SHA384-512等。

MD4、MD5算法的碰撞性已被攻破，SHA0、SHA1算法存在缺陷不推荐使用，因此推荐使用的是SHA2和SHA3算法。

下面以SHA256为例详细描述哈希算法的计算过程。

#### 常量初始化

首先介绍一下SHA256算法需要用到的常量以及逻辑运算。

SHA256算法使用到的**8个哈希初值：**
```
(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
h0 := 0x6a09e667
h1 := 0xbb67ae85
h2 := 0x3c6ef372
h3 := 0xa54ff53a
h4 := 0x510e527f
h5 := 0x9b05688c
h6 := 0x1f83d9ab
h7 := 0x5be0cd19
```
用到的**64个常量：**
```
k[0..63] :=
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
```
**需要到的逻辑运算**

SHA256用到的逻辑运算包括：

![abc](密码技术与物联网安全之单向散列函数/logic_function.png)

其中：

![abc](密码技术与物联网安全之单向散列函数/logic_symbol.png)

#### 消息预处理

算法首先要对消息进行填充。

**消息填充**

SHA256算法的分组长度是512bit，因此需要先经过填充使长度达到512的整数倍。
假设原始数据长度是L比特，则在后面填充一个比特1、K个比特0和长度L的二进制表示（64比特）。
` K = (512 - 64 - 1 - L) mod 512`
假设消息是"abc"，则填充后的消息为：
![abc](密码技术与物联网安全之单向散列函数/abc.png)

**消息分割:**

完成消息填充后，将消息M其分解成N个512比特的分组chunk： `M(1)~M(N)`。

#### 哈希计算

计算哈希的过程，就是对消息进行`N`轮的映射计算的过程，表示为：

```
H_i = Map(H_i-1, M(i))          //最外层循环，N轮
```    
 
H_0是前面提到的8个哈希初值，利用Map映射函数对H进行更新，更新N轮后的输出H_N，就是最后的哈希值。

**Map映射函数**

首先，Map映射函数需要构造64个字(**WORD**)

每个512比特的分组消息M(i)，可以用16个32比特表示：

`w[0],...,w[15]`

它们是64个字的前16个，后面的字由如下迭代公式的到：

`w[t] = σ1(w[t-2]) + w[t-7] + σ0(w[t-15]) + w[t-16]`

然后，Map映射包含了64次循环，每次循环的过程为：

![map](密码技术与物联网安全之单向散列函数/1280px-SHA-2.svg.png)

其中：

- 输入ABCDEFGH这8个字一开始的初值分别为：H_i-1(0),...,H_i-1(7),它们按照上图中的规则进行更新；

- 深蓝色方块是实现定义好的非线性逻辑函数；

- 红色田字方块表示:两个数字相加，对2^32求余；

- Kt是第t个密钥，对应前面提到的64个常量；

- Wt是本区块第t个word。

由此完成了SHA256的计算。

